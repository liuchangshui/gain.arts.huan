# 二项分布的递归实现
## 题目
* 题目描述

```
1.1.27 二项分布，估算使用 binomial(int N, int k, double p) 的代码计算binomial(100,50)的值，需要调用递归的次数。基于数组，保存计算的值，开发一个更好的实现。

public static double binomial(int N, int k, double p){
    if(N==0 && k==0){
        return 1.0;
    }
    if(N<0 || k<0){
        return 0.0;
    }
    return (1.0-p)*binomial(N-1, k, p) + p*binomial(N-1, k-1, p);
}
```

## 知识点拆分
面对一个问题的时候，首先是理解题目，然后根据题意将题目拆分成一个个小问题，然后将小问题解决掉，再按照逻辑关系组合就可以将大问题解决了.

* 首先我们先要将题目给拆分成若干个小问题 ：

	1、	二项分布是什么？

	2、	题目中的代码与二项分布的关系是什么？

	3、	基于数组重写题目中的代码遵循的逻辑思路是什么？
	
* 其次将拆分出来的问题梳理出逻辑关系：

	1、 这个题目的目的是用程序实现二项分布，因此理解二项分布是解决问题的基础。
	
	2、 代码是为了实现二项分布，因此代码与二项分布的关系，是建立在理解二项分布原理的接触上，从而确定的。
	
	3、 基于数组的代码逻辑与递归调用的代码逻辑是不一样的，递归调用是收敛的方式去解决问题，数组暂存数据是通过升序的方式去解决问题的。
	

## 知识点介绍

### 什么是二项分布？

二项分布的定义：从N个独立的是/非实验中，成功次数的离散概率分布。每次实验的成功概率为p。

* 对于二项分布的定义我们可以这样理解：

	1、 N个独立的是/非实验：表明二项分布研究的问题，是基于实验结果只有两种且相互之间无影响的情况。
	
	2、 成功次数的离散概率分布：表明二项分布求取的结果是对于在这样的一个实验中，不同成功次数所拥有的的概率数。
	
	3、	每次实验的成功概率为p：每次实验的成功与失败概率不因为实验次数而受到影响，总是p。
	
#### 二项分布要解决哪些问题？	

* 对于以上二项式的解读，可以通过抛硬币的例子进行具象化，首先，每次抛硬币出现的结果只能有两种，而且是相互独立的；其次，每次抛硬币出现正面的概率都是恒定的50%；最后，二项分布就是为了解决，如：抛硬币十次，出现0、1、2……10次正面情况的概率分别是多少的问题。
* 在实际生活中有很多类似抛硬币的问题需要利用二项分布去解决。如：大鸭梨手机品牌商要求豪士康工厂提供的手机产品合格率需要达到99%以上，否则将退货处理，当豪士康公司向大鸭梨手机厂商第一批供货10000部手机时，大鸭梨公司将安排质检员进行抽样检查，抽检方案为抽样100台手机，当不合格产品为1台和0台时就接收此批次产品，否则就退回此批次产品，那么我们就要思考如果此批次豪士康公司出产的手机实际合格率为98%的话，抽检通过的概率是多少呢？

	1、这其实是一个典型的二项分布问题，求取当事件概率为$1-0.98=0.02$时，实验次数为100次，出现不合格产品次数为0和1的概率数是多少？也就等价于抽检通过的概率了。

#### 二项分布的数学模型建立过程
在上节中，我们尝试用定义和实际生活中的例子来描述和解释二项分布所要解决的问题，那么二项分布在数学层面应该是如何表示呢，接下来将继续用抛硬币的例子进一步说明二项分布的公式是如何推导出来的，虽然不是数学家那样证明公式定理的方法，但会更加便于大家的理解。

设想如下场景，当抛两次硬币时，出现一次正面的几率多大？首先我们看抛两次硬币一共会出现多少种可能的场景：

* 正正
* 正反
* 反正
* 反反

一共会出现四种场景，而仅出现一次正面的场景的概率是 $2/4=0.25$ 可能出现正面的次数是：$2$，看到这样的一个结果，大家是否想起了我们高中时学习的排列组合的知识点。我们继续将这个例子扩大范围。

设想如下场景，当抛三次硬币时，出现一次正面的几率多大？首先我们看抛两次硬币一共会出现多少种可能的场景：

* 正正正
* 正正反
* 正反正
* 正反反
* 反正正
* 反正反
* 反反正
* 反反反
 
一共会出现八种场景，而仅出现一次正面的场景的概率是 $3/8=0.375$ 可能出现正面的次数是：$3$，这个值和上面的例子其实都可以由排列组合的公式得出：
 
$$
C_{n}^{k} = \frac{n!}{k!(n-k)!}
$$

我们将数据代入公式就知道是否正确了，第一个例子，$n=2,k=1$，结果是：$2$:

$$
C_{2}^{1} = \frac{2!}{1!(2-1)!} = 2
$$

第二个例子，$n=3,k=1$，结果是：$3$:

$$
C_{3}^{1} = \frac{3!}{1!(3-1)!} = 3
$$

排列组合的知识点就不在篇文章复习了，上面的计算公式是组合公式，具体定义描述引用过来如下：
>组合（combination），数学的重要概念之一。从n个不同元素中每次取出m个不同元素（0≤m≤n），不管其顺序合成一组，称为从n个元素中不重复地选取m个元素的一个组合。所有这样的组合的总数称为组合数--来自百度百科

我们知道了组合数的概念后，就知道抛$n$次硬币，出现正面$k = 0，1，2……n$次的组合数分别是多少了，只要代入公式计算即可，但是这里面还有个重要的问题我们没有考虑进来，就是我们开篇就提到的一个概念，独立实验中的恒定概率$p$，是如何在这里起到作用的，之所以我们在抛硬币的时候没有把$p$引进过来，是因为抛硬币时出现正反面的概率是相等的，因此出现正面的概率是$0.5$,所以我们可以不把$p$，引进过来，但是隐藏掉概率，不代表概率就不起作用了。

首先需要思考的问题是概率是如何起作用的，当我们抛了$3$次硬币后，我们可以计算出出现$1$次正面的组合数是$3$,也就意味着$3$次中有$2$次是反面,$1$次是正面，我们设出现正面的概率$p=0.5$，出现反面的概率$q=0.5$.

那么上面的情况就可以描述为 $C_{n}^{k}p^kq^{n-k} =C_{3}^{1}p^1q^{3-1} = 3*0.5^1*0.5^2$，代表着抛三次，其中有一次出现的是正面，两次出现的是反面。写到这里我们其实已经把二项分布的公式给引出来了

$$
C_{n}^{k}p^kq^{n-k}=(C_{n-1}^k+C_{n-1}^{k-1})p^kq^{n-k}
=C_{n-1}^kp^kq^{n-k}+C_{n-1}^{k-1}p^kq^{n-k}
=qC_{n-1}^kp^kq^{n-k-1}+pC_{n-1}^{k-1}p^{k-1}q^{n-k}
$$

其中$C_{n}^{k}$代表抽检样本数$n$的前提下，出现成功次数为$k$的组合数，$p^kq^{n-k}$代表，成为$k$次的概率和失败为$k-n$次的概率，$=$号后面的推导式是将$C_{n}^{k}$进行了拆分，然后将整个式子演化成:

$$C_{n}^{k}p^kq^{n-k}=qC_{n-1}^kp^kq^{n-k-1}+pC_{n-1}^{k-1}p^{k-1}q^{n-k}$$

不难看出来，这个等式用程序实现的最简单办法就是用归递的方式来实现，将$C_{n}^{k}p^kq^{n-k}$设为$binomial (n,k,p)$函数，那么对应上面的推导式，我们就可以用$binomial$函数写成如下格式：

$$binomial(n,k,p) = (1-p)*binomial(n-1,k,p)+p*bimomial(n-1,k-1,p)$$

而$n$是样本数，$k$是成功次数，所以，$n,k$都不能小于$0$,若$n,k$有任意一个数小于零，就应该将函数值设置为$0$,如果$n,k$等于零，那么我们知道$0!=1,且，n^0=1$所以此时$n,k=0，binomial(n,k,p)=1$，通过上面的分析，我们找出了函数

$$binomial(n,k,p) = (1-p)*binomial(n-1,k,p)+p*bimomial(n-1,k-1,p)$$

的边界，即$n=1&&k=1和n<0||k<0$的情况下，函数的值应该是多少。

###题目中的代码与二项分布的关系
我们从上面的二项分布知识点的介绍中会获取到一个结论，即$$binomial(n,k,p) = (1-p)*binomial(n-1,k,p)+p*bimomial(n-1,k-1,p)$$
因此现在再来看我们的代码：

```
public static double binomial(int N, int k, double p){
    if(N==0 && k==0){
        return 1.0;
    }
    if(N<0 || k<0){
        return 0.0;
    }
    return (1.0-p)*binomial(N-1, k, p) + p*binomial(N-1, k-1, p);
    //binomial(n,k,p) = (1-p)*binomial(n-1,k,p)+p*bimomial(n-1,k-1,p)
}
```

其本质也是根据$binomial(n,k,p) = (1-p)*binomial(n-1,k,p)+p*bimomial(n-1,k-1,p)$这个等式来的。但是这样的递归程序实现虽然能够快速的将二项分布用程序代码写出来，但是随着$n,k$越来越大，递归调用深度就会越来越多，程序效率将急剧下降，我们可以把程序的调用路径简化成一个完全二叉树，那么程序的调用次数就是以$k$为指数的$2^k$次，当$k$的值增大到一定程度，大家可以想象程序的效率将会怎么样？

所以在学习和了解的层面我们可以采用递归方式来实现这样一个数学公式，但是在真正的生产过程中，用递归方法来实现二项分布将是不可取的，那么什么方法来实现这样的数学公式或者换一种说法，用什么方法来改写递归方程呢？

###基于数组重写题目中的代码遵循的逻辑思路
要回答上一小节提出的问题“用什么方法来改写递归方程呢？”，我通常的解决方案分为如下几步：

* 理解问题
* 归纳问题
* 提出方案
* 验证方案
* 改进方案
* 确定方案

####理解问题
递归方程本质上是利用计算过程收敛的特性，和递归方程重复调用的特性，将大问题逐步分割成层层的小问题。在二项分布的方程上，我们来看下是如何体现的，为了能看的更清楚，我将$n=3,k=2,p=0.4$：

	binomial(3,2,0.4)
	|
	|--0.6*binomial(2,2,0.4)
	|	|
	|	|--0.6*binomial(1,2,0.4)
	|	|	|
	|	|	|--0.6*binomial(0,2,0.4)
	|	|	|	|
	|	|	|	|--0.6*binomial(-1,2,0.4)
	|	|	|	|
	|	|	|	|--0.4*binomial(-1,1,0.4) %
	|	|	|
	|	|	|--0.4*binomial(0,1,0.4) *
	|	|		|
	|	|		|--0.6*binomial(-1,1,0.4) %
	|	|		|
	|	|		|--0.4*binomial(-1,0,0.4) &
	|	|
	|	|--0.4*binomial(1,1,0.4) #
	|		|
	|		|--0.6*binomial(0,1,0.4) *
	|		|	|
	|		|	|--0.6*binomial(-1,1,0.4) %
	|		|	|
	|		|	|--0.4*binomial(-1,0,0.4) &
	|		|
	|		|--0.4*binomial(0,0,0.4) -
	|
	|
	|--	0.4*binomial(2,1,0.4)
		|
		|--0.6*binomial(1,1,0.4) #
		|	|
		|	|--0.6*binomial(0,1,0.4) *
		|	|	|
		|	|	|--0.6*binomial(-1,1,0.4) %
		|	|	|
		|	|	|--0.4*binomial(-1,0,0.4) &
		|	|
		|	|--0.4*binomial(0,0,0.4) -
		|
		|--0.4*binomial(1,0,0.4)
			|
			|--0.6*binomial(0,0,0.4) -
			|
			|--0.4*binomial(0,-1,0.4)


####归纳问题
在节点上标记出特殊符号的说明做了重复计算，也即是说在收敛的过程中，二叉树的节点是有重复的，而这个重复的数据会随着样本数据增多而快速增多，进而降低程序效率。如果要解决递归过程中的效率问题，我们基于前述分析，可以考虑将重复的计算控制在有限次数内，最好是一次计算完后就不需要再次计算了。

####提出方案
因此可以考虑将计算过程中的计算结果暂存在一个变量中，这样在需要的时候就可以快速的获取到这个结果了，基于二项分布的收敛特点和参数特点，我们需要考虑如下维度：

* 收敛特点：通过收敛特点，我们知道递归调用是降级计算，那么如果上一级的计算想要计算出结果，就需要下一级的计算结果提前算出来，所以若选择暂存计算结果的方案，需要做升级计算，即先计算低级数据，然后才能推导出高级输出，类似于斐波那契数列的概念。
* 参数特点：从【理解问题】小节中我们看到，确定计算结果其实本质上是由$k,n$两个数据决定的，而我们要存多个以$k,n$为维度的数据值，比较好的数据结构方式可以选择二维数组来存储计算过程中的数据。

####验证方案&确定方案
从前面的分析中，我们就可以编写出以二维数组暂存数据的二项分布程序代码:

```
public static double binomialWithArray(int N,int k,double p){
        double[][] binomialArrays = new double[N+1][k+1];

        binomialArrays[0][0] = 1.0;
        for (int i=1; i<=N; i++){
            binomialArrays[i][0] = (1-p)*binomialArrays[i-1][0];
        }

        for (int i=1; i<=N; i++){
            for (int j=1; j<=k; j++){
                binomialArrays[i][j] = (1-p)*binomialArrays[i-1][j] + p*binomialArrays[i-1][j-1];
            }
        }
        return binomialArrays[N][k];

    }
    
```



## 参考文献
1.[二项分布（1.1.27 Binomial distribution）的递归算法，基于数组进行改进](https://blog.csdn.net/hefrankeleyn/article/details/86345815)

2.[AlgorithmDemo4Demo/BinomialSample.java](https://github.com/kysonzhu/AlgorithmDemo4Demo/blob/master/src/com/kyson/chapter1/section1/BinomialSample.java)




